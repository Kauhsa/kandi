% --- Template for thesis / report with tktltiki2 class ---
% 
% last updated 2013/02/15 for tkltiki2 v1.02

\documentclass[finnish]{templates/tktltiki2}

% tktltiki2 automatically loads babel, so you can simply
% give the language parameter (e.g. finnish, swedish, english, british) as
% a parameter for the class: \documentclass[finnish]{tktltiki2}.
% The information on title and abstract is generated automatically depending on
% the language, see below if you need to change any of these manually.
% 
% Class options:
% - grading                 -- Print labels for grading information on the front page.
% - disablelastpagecounter  -- Disables the automatic generation of page number information
%                              in the abstract. See also \numberofpagesinformation{} command below.
%
% The class also respects the following options of article class:
%   10pt, 11pt, 12pt, final, draft, oneside, twoside,
%   openright, openany, onecolumn, twocolumn, leqno, fleqn
%
% The default font size is 11pt. The paper size used is A4, other sizes are not supported.
%
% rubber: module pdftex

% --- General packages ---

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{amsfonts,amsmath,amssymb,amsthm,booktabs,color,enumitem,graphicx}
\usepackage[pdftex,hidelinks]{hyperref}
\usepackage[parfill]{parskip}

% Automatically set the PDF metadata fields
\makeatletter
\AtBeginDocument{\hypersetup{pdftitle = {\@title}, pdfauthor = {\@author}}}
\makeatother

% --- Language-related settings ---
%
% these should be modified according to your language

% babelbib for non-english bibliography using bibtex
\usepackage[fixlanguage]{babelbib}
\selectbiblanguage{finnish}

\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
\newcommand{\RegionMarkerTok}[1]{{#1}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
\newcommand{\NormalTok}[1]{{#1}}

\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}

\usepackage{setspace}
\onehalfspacing

\sloppy

% add bibliography to the table of contents
\usepackage[nottoc]{tocbibind}
% tocbibind renames the bibliography, use the following to change it back
\settocbibname{Lähteet}

% --- Theorem environment definitions ---

\newtheorem{lau}{Lause}
\newtheorem{lem}[lau]{Lemma}
\newtheorem{kor}[lau]{Korollaari}

\theoremstyle{definition}
\newtheorem{maar}[lau]{Määritelmä}
\newtheorem{ong}{Ongelma}
\newtheorem{alg}[lau]{Algoritmi}
\newtheorem{esim}[lau]{Esimerkki}

\theoremstyle{remark}
\newtheorem*{huom}{Huomautus}


% --- tktltiki2 options ---
%
% The following commands define the information used to generate title and
% abstract pages. The following entries should be always specified:

\title{MapReduce-ohjelmointimalli}
\author{Mika Viinamäki}
\date{\today}
\level{Kandidaatintutkielma}
\abstract{Abstrakti}

% The following can be used to specify keywords and classification of the paper:

\keywords{hajautettu laskenta, MapReduce}

% classification according to ACM Computing Classification System (http://www.acm.org/about/class/)
% This is probably mostly relevant for computer scientists
% uncomment the following; contents of \classification will be printed under the abstract with a title
% "ACM Computing Classification System (CCS):"
% \classification{}

% If the automatic page number counting is not working as desired in your case,
% uncomment the following to manually set the number of pages displayed in the abstract page:
%
% \numberofpagesinformation{16 sivua + 10 sivua liitteissä}
%
% If you are not a computer scientist, you will want to uncomment the following by hand and specify
% your department, faculty and subject by hand:
%
% \faculty{Matemaattis-luonnontieteellinen}
% \department{Tietojenkäsittelytieteen laitos}
% \subject{Tietojenkäsittelytiede}
%
% If you are not from the University of Helsinki, then you will most likely want to set these also:
%
% \university{Helsingin Yliopisto}
% \universitylong{HELSINGIN YLIOPISTO --- HELSINGFORS UNIVERSITET --- UNIVERSITY OF HELSINKI} % displayed on the top of the abstract page
% \city{Helsinki}
%

\begin{document}

% --- Front matter ---

\frontmatter      % roman page numbering for front matter

\maketitle        % title page
\makeabstract     % abstract page

\tableofcontents  % table of contents

% --- Main matter ---

\mainmatter       % clear page, start arabic page numbering

\section{Johdanto}\label{johdanto}

Suurten tietomäärien kerääminen ja analysointi on usein hyödyllistä
liiketoiminnan ymmärtämisen ja tehostamisen kannalta. Esimerkiksi
verkkokaupankäyntiin erikoistunut eBay kertoi vuonna 2013 säilyttävänsä
tietovarastoissaan lähes 90 petatavua kaupankäyntiin liittyvää dataa
\footnote{Inside eBay's 90PB data warehouse:
  \url{http://www.itnews.com.au/News/342615,inside-ebay8217s-90pb-data-warehouse.aspx}}.
Tarvetta suurten tietomäärien käsittelyyn esiintyy kuitenkin muuallakin
kuin yrityksissä -- vuonna 2010 fysiikan tutkimukseen käytetyn
\emph{Large Hadron Colliderin} päätunnistimen tuottamasta datasta jäi
karsimisen jälkeen analysoitavaksi noin 13 petatavua dataa
\cite{lhc}. Tällaiset useiden kymmenien petatavujen suuruiset
tietovarastot ovat suuruudeltaan monikymmentuhatkertaisia verrattuna
tyypillisen kuluttajatietokoneen massamuistin kapasiteettiin \footnote{Pelijulkaisualusta
  \emph{Steam} julkaisee kuukausittain tilastoja käyttäjiensä
  tietokoneista, mukaan lukien massamuistin koon -- tätä kirjoittaessa
  yleisimmäksi massamuistin kooksi raportoidaan 250-499 gigatavua:
  \url{http://store.steampowered.com/hwsurvey/}}. Näin suuria
tietomääriä onkin vaikea käsitellä käyttäen laskentaan vain yhtä
tietokonetta.

Tässä tutkielmassa \emph{hajautetulla laskennalla} tarkoitetaan kahden
tai useamman tietokoneen hyödyntämistä jossain laskentaoperaatiossa.
Hajautettua laskentaa voi tehdä käyttämällä esimerkiksi joukkoa
tietoliikenneyhteyksillä toisiinsa yhdistettyjä itsenäisiä, usein
yleisesti saatavilla olevista komponenteista rakennettuja tietokoneita.
Tällaista joukkoa tietokoneita kutsutaan \emph{klusteriksi}
\cite{cluster-computing}. Yleisesti saatavilla olevista
komponenteista rakennettujen klustereiden käyttö vaativiin
laskentaoperaatioihin on havaittu erityisvalmisteisia supertietokoneita
edullisemmaksi \cite{cluster-computing}.

Suurten datan käsittelyyn erikoistuneiden yritysten, kuten Googlen,
klustereihin voi kuulua satoja tai tuhansia tietokoneita
\cite{mapreduce}. Hyödyntääkseen hajautettua laskentaa ei ole
kuitenkaan välttämätöntä tehdä suuria investointeja. Oman
tietokoneklusterin hankkimisen sijaan yritykset voivat käyttää hyväkseen
infrastruktuuria tai laskentaa palveluna tarjoavia yrityksiä, jolloin
kustannuksia syntyy vain palvelun käytöstä \cite{cloudcomputing}.

Klusterissa tehtyyn laskentaan liittyy kuitenkin haasteita, joita
yhdellä koneella tehdyssä laskennassa ei esiinny. Koska laskentaan
osallistuu useampi tietokone, klusteria hyödyntävän ohjelman täytyy
jakaa laskentatehtävä usealle tietokoneelle ja huolehtia
kommunikaatiosta laskentaan osallistuvien tietokoneiden välillä
\cite{cluster-grid-cloud}, mikä tekee klusterissa tehdyssä
laskennasta yhdellä koneella tehtävää laskentaa monimutkaisempaa.
Lisääntyneestä monimutkaisuudesta huolimatta suurten tietomäärien
käsittelyyn tarvitaan useampaa tietokonetta, sillä yhdellä tietokoneella
ei voida käsitellä yhtä suuria tietomääriä kuin usealla tietokoneella.

Tutkielma esittelee MapReduce-ohjelmointimallin, joka on menetelmä
käsitellä suuria tietomääriä hajautetusti. Luvussa 2 käydään läpi
ohjelmointimalli sekä sen toiminta. Luvussa 3 esitellään kaksi erilaista
MapReduce-suorituskyvyn parantamiseen tähtäävää optimointia, indeksointi
sekä \emph{combiner}-vaihe. Luku 4 näyttää esimerkin ohjelmointimallin
käyttämisestä PageRank-menetelmän toteuttamisessa. Luvussa 5 esitellään
kaksi muuta hajautetun laskennan ratkaisua, hajautetut
relaatiotietokannat ja Spark-ohjelmistokehys sekä verrataan niitä
MapReduce-ohjelmointimalliin. Luku 6 päättää tutkielman.

\section{MapReduce-ohjelmointimalli}\label{mapreduce-ohjelmointimalli}

MapReduce on Googlen vuonna 2003 kehittämä ohjelmointimalli \cite[
s. 72]{mapreduce2}, jota käytetään suurten tietomäärien käsittelyyn ja
tuottamiseen \cite{mapreduce}. Ohjelmointimallin
tarkoituksena on vähentää hajautetun laskennan monimutkaisuutta
tarjoamalla useaan hajautetun laskennan sovellukseen sopiva abstraktio
\cite{mapreduce}. Käyttämällä sovelluksessaan
MapReduce-kirjastoa ohjelmoijan ei tarvitse huolehtia monista
hajautettuun laskentaan liittyvistä yksityiskohdista, kuten
tietokoneiden välisestä kommunikaatiosta \cite{mapreduce}.
Eräs tunnettu MapReduce-ohjelmointimallin toteutus on osa avoimen
lähdekoodin Apache Hadoop -projektia, jonka käyttäjiin kuuluvat muun
muassa Facebook ja Yahoo! \cite{hive}.

\subsection{\emph{Map}- ja
\emph{reduce}-funktiot}\label{map--ja-reduce-funktiot}

MapReduce-ohjelmointimallissa käyttäjä toteuttaa kaksi funktiota, joita
kutsutaan nimillä \emph{map} ja \emph{reduce}. Funktiot ovat
funktionaalisessa ohjelmoinnissa esiintyvien samannimisten funktioiden
inspiroimia \cite{mapreduce}, mutta eivät suoraan vastaa
näitä funktioita \cite{mapreduce-revisited}. Funktiota
\emph{map} käytetään käsittelemään syötteen alkioita, ja funktiota
\emph{reduce} käytetään yhdistämään alkiot.

Funktioiden \emph{map} ja \emph{reduce} tyypit on määritelty näin
\cite{mapreduce}: \[
\begin{aligned}
map &: (k1, v1) \to list(k2, v2) \\
reduce &: (k2, list(v2)) \to list(v2)
\end{aligned}
\]

Funktion \emph{map} tarkoituksena on tuottaa tuloksia, joita myöhemmin
käytetään \emph{reduce}-funktion syötteenä \cite{mapreduce}.
\emph{Map}-funktio muuntaa MapReduce-ohjelman syötteenään saamat
avain-arvo-parit uusiksi avain-arvo-pareiksi. Näitä \emph{map}-funktion
tuloksia kutsutaan \emph{välituloksiksi}. MapReduce-ohjelmointimalli ei
ota kantaa minkään syötteen tai tuloksen avaimen tai arvon merkitykseen,
vaan se riippuu käyttäjän syötteestä sekä \emph{map}- ja
\emph{reduce}-funktioiden toteutuksesta.

Ohjelmointimallin toimintaa havainnollistaa seuraava
pseudokoodimuotoinen esimerkki, joka laskee \emph{kissa}- ja
\emph{koira}-sanojen esiintymien lukumäärää joukossa tekstimuotoisia
dokumentteja:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \DataTypeTok{map}\NormalTok{(avain, arvo):}
    \CommentTok{# avain: dokumentin nimi}
    \CommentTok{# arvo: dokumentin sisältö}
    \KeywordTok{for} \NormalTok{sana in arvo:}
        \KeywordTok{if} \NormalTok{sana == }\StringTok{"koira"}\NormalTok{:}
            \NormalTok{emit(}\StringTok{"koira"}\NormalTok{, }\DecValTok{1}\NormalTok{)}
        \KeywordTok{elif} \NormalTok{sana == }\StringTok{"kissa"}\NormalTok{:}
            \NormalTok{emit(}\StringTok{"kissa"}\NormalTok{, }\DecValTok{1}\NormalTok{)    }
\end{Highlighting}
\end{Shaded}

Esimerkin \emph{map}-funktio käy syötteenä saadun dokumentin jokaisen
sanan läpi ja tuottaa avain-arvo-parin, mikäli sana on \emph{koira} tai
\emph{kissa}. Avaimena käytetään löydettyä sanaa ja arvona kokonaislukua
\(1\). Käyttäjän tarjoaman \emph{map}-funktion soveltaminen kaikille
syötteen avain-arvo-pareille -- tässä tapauksessa syötteenä käytetyille
dokumenteille -- on laskennan ensimmäinen vaihe. \emph{Map}-vaiheen
jälkeen joukko välituloksia voisi näyttää esimerkiksi tältä: \[
(kissa, 1), (koira, 1), (kissa, 1), (koira, 1), (kissa, 1), (kissa, 1).
\]

Laskennan toinen vaihe on käyttäjän tarjoaman \emph{reduce}-funktion
soveltaminen niihin välituloksiin, joilla on keskenään sama avain.
Seuraava \emph{reduce}-funktio laskee yhteen saman sanan esiintymien
lukumäärät:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \DataTypeTok{reduce}\NormalTok{(avain, arvot):}
    \CommentTok{# avain: sana, "kissa" tai "koira"}
    \CommentTok{# arvot: lista sanan esiintymien lukumääriä}
    \NormalTok{summa = }\DecValTok{0}
    \KeywordTok{for} \NormalTok{arvo in arvot:}
        \NormalTok{summa += arvo}
    \NormalTok{emit(summa)}
\end{Highlighting}
\end{Shaded}

Jos laskennan tulos vastasi \emph{map}-vaiheen jälkeen aiemmin
esittämäämme mahdollista tulosta, näyttää laskennan tulos
\emph{reduce}-vaiheen jälkeen tältä: \[
(kissa, 4), (koira, 2).
\]

Kuvassa 1 havainnollistetaan määriteltyjä \emph{map}- ja
\emph{reduce}-funktioita. \emph{Map}- ja \emph{reduce}-funktioihin
nuolella viittaavat laatikot kuvaavat funktioiden syötettä, ja
funktiosta poispäin viittatut laatikot funktion tulosta.

\begin{figure}[htbp]
\centering
\includegraphics{dist/map-and-reduce.pdf}
\caption{Mahdollinen MapReduce-laskentatehtävän syöte, välitulokset ja
lopullinen tulos}
\end{figure}

\subsection{MapReduce-ohjelman suorituksen
kulku}\label{mapreduce-ohjelman-suorituksen-kulku}

Googlen esittelemässä MapReduce-ohjelmointimallin toteutuksessa ohjelman
suoritus alkaa käynnistämällä käyttäjän ohjelmasta kopio kaikilla
laskentaan osallistuvilla tietokoneilla \cite{mapreduce}. Yksi
näistä kopioista on \emph{isäntäprosessi} (master), joka koordinoi
laskennan kulkua. Muut ohjelman kopiot ovat varsinaisen laskennan
suorittavia \emph{työprosesseja} (worker).

Jos syöte ei ole valmiiksi jaettu, se jaetaan pieniin osiin. Näitä osia
kutsutaan \emph{jaoiksi} (split), ja jokaiseen jakoon saattaa kuulua
yksi tai useampi \emph{map}-funktiolle annettava syötteen alkio.
Jokaisesta jaosta muodostetaan \emph{map}-laskentatehtävä, jonka
isäntäprosessi luovuttaa jollekin työprosessille laskettavaksi. Syötteen
jakaminen mahdollistaa sen käsittelyn useassa työprosessissa
samanaikaisesti.

\emph{Map}-laskentatehtävien tuloksena saatavista välituloksista
muodostetaan \emph{osia} (partition). Jokainen yksittäinen välitulos
tallennetaan johonkin osaan, joka valitaan soveltamalla
\emph{hajautusfunktiota} välituloksen avaimeen. Näin saadaan aikaan
osia, joissa eri avaimet ovat jakautuneet tasaisesti eri osien kesken ja
joissa kaikki saman avaimen välitulokset päätyvät samaan osaan.

Jokaisesta osasta muodostetaan \emph{reduce}-laskentatehtävä.
Isäntäprosessi sijoittaa \emph{reduce}-laskentatehtävät työprosessien
laskettaviksi \emph{map}-laskentatehtävien tavoin. Ennen
\emph{reduce}-funktion soveltamista välituloksiin työprosessi järjestää
yhden osan välitulokset avaimen mukaan. Näin välitulokset joilla on sama
avain ovat osan sisällä peräkkäin, ja avaimia voidaan käsitellä
\emph{reduce}-funktiolla yksi kerrallaan. Kun \emph{reduce}-operaatio on
yhden avaimen osalta valmis, laskenta on tämän avaimen välitulosten
osalta tehty.

MapReduce-ohjelmointimalli ei rajoita syötteen lataamiseen tai tuloksen
tallentamiseen käytettyjä tapoja. Syötteenä voidaan esimerkiksi käyttää
joukkoa tiedostojärjestelmässä olevia tiedostoja, mutta
ohjelmointimallin toteutus voi lisäksi mahdollistaa esimerkiksi
tietokannan käytön syötteenä tai tuloksen tallennuskohteena \cite[s.
74]{mapreduce2}. Usein MapReduce-laskentatehtäviä halutaan ketjuttaa
käyttäen saatua tulosta uuden MapReduce-laskentatehtävän syötteenä
\cite{mapreduce}.

\begin{figure}[htbp]
\centering
\includegraphics{dist/mapreduce-operation.pdf}
\caption{MapReduce-laskentatehtävän suorituksen kulku}
\end{figure}

Kuva 2 havainnollistaa yllä esiteltyä MapReduce-laskentatehtävän
suorituksen kulkua. Kuvassa näytetään, minkä laskentatehtävän alle
laskennan eri osat kuuluvat. Toisin kuin kuvan syötteellä, on yhteen
osaan mahdollista kuulua useamman kuin yhden avaimen omaavia
välituloksia.

\section{MapReducen optimointeja}\label{mapreducen-optimointeja}

MapReduce-ohjelmointimallia sellaisenaan voidaan pitää melko
yksinkertaisena. Ohjelmointimallin suorituskykyä voidaan kuitenkin
parantaa laajentamalla sen toimintaa. Tässä luvussa tutustutaan kahteen
MapReduce-ohjelmointimallin suorituskyvyn parantamiseen tähtäävään
optimointiin, \emph{combiner}-vaiheeseen sekä indeksointiin.

\subsection{Combiner}\label{combiner}

\begin{figure}[htbp]
\centering
\includegraphics{dist/combiner.pdf}
\caption{MapReduce-laskentatehtävä \emph{combiner}-funktiolla
varustettuna}
\end{figure}

Dean ja muut \cite{mapreduce} esittelevät
MapReduce-ohjelmointimallin lisäksi optimoinnin, joka lisää
MapReduce-operaatioon uuden vaiheen nimeltään \emph{combiner}.
\emph{Combiner}-vaiheen käyttö nopeuttaa \emph{MapReduce}-operaation
suoritusta erityisesti tilanteissa, joissa saman avaimen omaavia
välituloksia on paljon.

Optimoinnin ideana on vähentää \emph{map}- ja
\emph{reduce}-laskentatehtävien välistä kommunikaatiota tekemällä
välitulosten osittaista yhdistämistä jo \emph{map}-laskentatehtävän
sisällä. Tämä toteutetaan soveltamalla \emph{combiner}-funktiota yhden
\emph{map}-laskentatehtävän välitulosten yhdistämiseen
\emph{reduce}-funktion tapaan. Seurauksena on, että \emph{map}- ja
\emph{reduce}-laskentatehtävien välillä tarvitsee siirtää vain yksi
välitulos jokaista avainta kohden. Näin ollen verkon yli
\emph{reduce}-laskentatehtäville lähetettävien välitulosten määrä
vähenee. \emph{Combiner}-funktion käyttämistä havainnollistetaan kuvassa
3. Kuvaan 2 verrattuna \emph{map}- ja \emph{reduce}-laskentatehtävien
välistä kommunikaatiota on vähemmän.

\emph{Combiner}-funktio toimii \emph{reduce}-funktion tapaan, ja
\emph{combiner}-funktiona voidaankin usein käyttää
\emph{reduce}-funktioksi määriteltyä funktiota. \emph{Combiner}-funktion
käyttö muuttaa kuitenkin MapReduce-laskennan kulkua, sillä
\emph{combiner}-funktion käytöstä seuraa, että \emph{reduce}-funktio ei
saa enää parametrikseen kaikkia yhden avaimen välituloksia. Tästä
seuraa, että kaikkia \emph{reduce}-funktiota ei voida käyttää
\emph{combiner}-funktiona: alla oleva funktio on esimerkki
\emph{combiner}-funktioksi soveltumattomasta \emph{reduce}-funktiosta.
\emph{Reduce}-funktiona käytettäessä funktion antama tulos kertoo,
kuinka monta \emph{kissa}- tai \emph{koira}-sanaa tarvitaan, jotta niitä
olisi sata.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# funktio toimii oikein reduce-funktiona,}
\CommentTok{# mutta ei combiner-funktiona}
\KeywordTok{def} \NormalTok{combiner_ja_reduce(avain, arvot):}
    \NormalTok{tarvitaan = }\DecValTok{100}
    \KeywordTok{for} \NormalTok{arvo in arvot:}
        \NormalTok{tarvitaan -= arvo}
    \NormalTok{emit(tarvitaan)}
\end{Highlighting}
\end{Shaded}

Käyttämällä tätä funktiota \emph{reduce}-funktion lisäksi
\emph{combiner}-funktiona tulokset olisivat virheellisiä, mutta
käyttämällä luvussa 2.1 määrittelemäämme \emph{reduce}-funktiota
\emph{combiner}-funktiona laskentatehtävän tulos pysyisi oikeana.
Täsmällisesti \emph{reduce}-funktiota voidaan käyttää myös
\emph{combiner}-funktiona jos \emph{reduce}-funktio on vaihdannainen
sekä liitännäinen \cite{mapreduce}.

\subsection{Indeksien käyttäminen}\label{indeksien-kuxe4yttuxe4minen}

MapReduce-ohjelmointimalli soveltuu sellaisenaan hyvin tarkoituksiin,
joissa halutaan käsitellä suuren tietomäärän kaikkia tietueita. Usein
kuitenkin halutaan käsitellä vain pientä osaa jostain tietomäärästä,
esimerkiksi jollain aikavälillä luotuja tai tietyn sanan sisältäviä
dokumentteja. Pelkästään näiden dokumenttien käsittely
MapReduce-ohjelmointimallin avulla edellyttää koko tietomäärän käymistä
läpi ja haluttujen dokumenttien suodattamista \emph{map}-vaiheessa, mikä
suurilla tietomäärillä saattaa olla hidasta \cite{hail}.

Tämän tyyppisten laskentatehtävien tehostamiseksi on luotu tekniikoita,
jotka laajentavat MapReduce-ohjelmointimallia \emph{indekseillä}.
Indeksillä tarkoitetaan tietorakennetta, jolla pyritään nopeuttamaan
tietueiden hakemista jonkin tietueeseen liittyvän kentän perusteella
\cite{indexing}. Indeksin käyttö kuitenkin edellyttää ensin indeksin
olemassaoloa, ja sen luominen saattaa olla paljon laskentaresursseja
vaativa operaatio -- tällöin indeksointi onkin perusteltua vain, mikäli
samaa syötettä käytetään laskentaoperaatioissa useita kertoja.

Richer ja muut esittelevät työssään \cite{hail} Apache Hadoop
-projektin päälle rakennetun \emph{Hadoop Aggressive Indexing Library}
(HAIL) -kirjaston, jonka avulla voidaan hyödyntää indeksointia
Hadoop-laskentatehtävissä. HAIL tarjoaa indeksin luomiseen kaksi
erilaista menetelmää, joista molemmat välttävät erillisen, indeksin
rakentavan laskentaoperaation. \emph{Staattinen indeksointi} tarkoittaa
tiedon indeksointia samalla, kun sitä siirretään Hadoop-projektiin
kuuluvaan hajautettuun tiedostojärjestelmään. \emph{Adaptiivinen
indeksointi} tarkoittaa indeksin rakentamista samalla, kun indeksoitavaa
dataa käytetään jonkin MapReduce-laskentatehtävän yhteydessä.
Adaptiivinen indeksointi mahdollistaa indeksin hyödyntämisen myös
sellaisella datalla, jolle ei ole rakennettu indeksiä hajautettuun
tiedostojärjestelmään siirtämisen yhteydessä.

Käyttäjä voi hyödyntää indeksiä esimerkiksi määrittelemällä
\emph{map}-funktion yhteyteen suodattimen, jolloin
\emph{map}-laskentatehtävä saa syötteekseen vain suodattimen hyväksymiä
tietueita. Koska indeksistä tietueiden hakeminen on nopeaa, on indeksin
käyttäminen suodatuksessa tehokkaampaa kuin datan suodattaminen vasta
\emph{map}-laskentatehtävän yhteydessä. Artikkelissa esiteltyjen
tuloksien mukaan datan siirtoon käytetyn HAIL-asiakasohjelman
tehokkuuden vuoksi staattinen indeksointi datan siirtämisen yhteydessä
ei ole hitaampaa kuin Hadoop-projektin mukana tulevan asiakasohjelman
käyttö datan siirtämiseen. Varsinaisen Hadoop-laskentatehtävän
suorituskykyä indeksin käyttäminen paransi 64-kertaisesti
\cite{hail}.

Indeksointia voi kuitenkin hyödyntää ilman, että
MapReduce-ohjelmointimallia laajennetaan millään tavalla. Tämä onnistuu
käyttämällä syötteenä tietoa, jonka muodostamisessa on käytetty
indeksointia. Tälläinen syöte voi olla esimerkiksi indeksejä käyttävän
tietokannan kyselyn tulos \cite{mapreduce2}.

\section{MapReducen sovellus:
PageRank}\label{mapreducen-sovellus-pagerank}

PageRank on menetelmä, jolla voidaan järjestää Internet-sivuja
tärkeysjärjestykseen niihin osoittavien linkkien perusteella
\cite{pagerank}. Menetelmän ajatuksena on, että usein viitatut
Internet-sivut ovat tärkeämpiä kuin sellaiset, joihin on vähemmän
viitattauksia. Mitä tärkeämpi sivu on, sitä enemmän sen viittaukset
nostavat viitattujen sivujen PageRank-arvoa. Google-hakukone sai alkunsa
PageRank-menetelmästä \cite{pagerank}. PageRank-menetelmä toimii
esimerkkinä hieman monimutkaisemmasta MapReduce-ohjelmointimallin avulla
toteutettavasta algoritmista.

Määritellään PageRank-menetelmän yksinkertaistettu versio. Olkoon \(s\)
jokin Internet-sivu, ja \(V_s\) sivuun \(s\) viittaavien sivujen joukko.
Internet-sivun \(s\) PageRank on nyt: \[
PageRank(s) = \sum_{v \in V_s} \frac {PageRank(v)} {linkkienMaaraSivulla(v)}
\]

Kuvassa 4 näytetään esimerkki PageRank-menetelmästä käytännössä. Kuvassa
on otos PageRank-arvon laskemiseen käytetyistä sivuista, niiden
PageRank-arvoista, sekä viittausten vaikutuksista sivujen
PageRank-arvoon.

\begin{figure}[htbp]
\centering
\includegraphics{dist/pagerank.pdf}
\caption{Esimerkki PageRank-menetelmästä}
\end{figure}

PageRank lasketaan usein käyttäen \emph{iteratiivista menetelmää}
\cite{pagerank-mapreduce}. Esimerkkinä iteratiivisesta menetelmästä
on seuraava algoritmi, joka laskee PageRank-arvon yksinkertaistetun
version jollekin joukolle sivuja siten. Algoritmissa sivujen
PageRank-arvot ovat aluksi karkeita, mutta tarkentuvat jokaisen
iteraation jälkeen.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Aseta jokaiselle sivulle PageRank-arvoksi jokin vakio, esimerkiksi 1.
\item
  Laske jokaiselle sivulle uusi PageRank-arvo käyttäen yllä esitettyä
  kaavaa siten, että laskettaessa uutta iteraatiota käytetään viime
  iteraation PageRank-arvoja.

  \[
  uusiPageRank(s) = \sum_{v \in V_s} \frac {edellinenPageRank(v)} {linkkienMaaraSivulla(v)}
  \]
\item
  Toista kohtaa 2, kunnes ollaan tehty haluttu määrä iteraatioita tai
  ollaan saavutettu haluttu tarkkuus.
\end{enumerate}

Toteutetaan tämän iteratiivisen algoritmin kohta 2. käyttäen
MapReduce-ohjelmointimallia. Aloitetaan määrittelemällä
MapReduce-ohjelmamme saama syöte. Algoritmi tarvitsee tiedon jokaisesta
Internet-sivusta, niiden nykyisistä PageRank-arvoista sekä listan
viittauksista toisiin Internet-sivuihin. Syötteeseen saadaan kaikki
tarvittava sisältö määrittelemällä se niin, että syötteen avaimena on
jokin sivun yksilöivä tunniste ja arvona pari, jonka ensimmäinen alkio
on sivun nykyinen PageRank-arvo ja toinen alkio sivulta löytyvät
viittaukset. Esitetään nämä viittaukset listana sivuja yksilöiviä
tunnisteita.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \DataTypeTok{map}\NormalTok{(sivu_id, (page_rank, viittaukset)):}
    \NormalTok{pr_per_viittaus = page_rank / }\DataTypeTok{len}\NormalTok{(viittaukset)}
    \KeywordTok{for} \NormalTok{viittaus in viittaukset:}
        \NormalTok{emit(viittaus, pr_per_viittaus)}
\end{Highlighting}
\end{Shaded}

Yllä määritelty \emph{map}-funktio luo jokaisesta sivulta löytyvästä
viittauksesta välituloksen, jonka avaimena on viitatun sivun tunniste ja
arvona viittavan sivun vaikutus viitatun sivun PageRank-arvoon. Nyt
\emph{reduce}-funktion tehtäväksi jää yhdistää nämä osittaiset
PageRank-arvot sivun lopulliseksi PageRank-arvoksi:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \DataTypeTok{reduce}\NormalTok{(sivu, arvot):}
    \NormalTok{page_rank = }\DecValTok{0}
    \KeywordTok{for} \NormalTok{arvo in arvot:}
        \NormalTok{page_rank += arvo}
    \NormalTok{emit(sivu, page_rank)}
\end{Highlighting}
\end{Shaded}

Määritelty MapReduce-ohjelma laskee jokaiselle sivulle uuden
PageRank-arvon ja näin suorittaa yhden iteraation aiemmin kuvaillusta
iteratiivisesta algoritmista. Algoritmissa on kuitenkin pieni ongelma:
ohjelman tuloksessa ei ole enää tietoja sivujen viittauksista toisiin
sivuihin. Niinpä ohjelman tulosta ei voi käyttää suoraan uuden
iteraation syötteenä. Koska algoritmi on iteratiivinen, mahdollisuus
käynnistää uusi iteraatio käyttäen syötteenä aiemman iteraation tulosta
on toivottu ominaisuus.

Ongelma voidaan ratkaista usealla eri tavalla. Koska sivujen väliset
viittaukset eivät muutu iteraatioiden välillä, ei ole välttämättä
mielekästä säilyttää tätä tietoa syötteessä lainkaan. Sen sijaan tiedot
sivujen välisistä viittauksista voidaan siirtää kaikille
työläisprosessien tietokoneille ennen iteraatioiden aloittamista,
jolloin \emph{map}-laskentatehtävät voivat lukea tiedot sivujen
välisistä viittauksista varsinaisen MapReduce-laskentatehtävässä
käytetyn syötteen ulkopuolelta.

Mikäli näin ei haluta tai voida menetellä, voidaan muuttaa
määrittelemiämme \emph{map}- ja \emph{reduce}-funktioita niin, että
tiedot sivujen välisistä viittauksista eivät häviä. Tämä voidaan
toteuttaa esimerkiksi käyttämällä kahden eri tyyppisiä välituloksia,
joista toiset ilmaisevat viittauksia sivulta toiselle ja toiset
vaikutuksia PageRank-arvoihin \cite{pagerank-mapreduce}. Alla olevat
\emph{map}- ja \emph{reduce}-funktiot toteuttavat tämän idean.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \DataTypeTok{map}\NormalTok{(sivu_id, (page_rank, viittaukset)):}
    \NormalTok{pr_per_viittaus = page_rank / }\DataTypeTok{len}\NormalTok{(viittaukset)}
    \KeywordTok{for} \NormalTok{viittaus in viittaukset:}
        \NormalTok{emit(viittaus, PageRank(pr_per_viittaus))}
        \NormalTok{emit(sivu_id, Viittaus(viittaus))}

\KeywordTok{def} \DataTypeTok{reduce}\NormalTok{(sivu_id, arvot):}
    \NormalTok{page_rank = }\DecValTok{0}
    \NormalTok{viittaukset = []}
    \KeywordTok{for} \NormalTok{arvo in arvot:}
        \KeywordTok{if} \DataTypeTok{type}\NormalTok{(arvo) == PageRank:}
            \NormalTok{page_rank += arvo}
        \KeywordTok{elif} \DataTypeTok{type}\NormalTok{(arvo) == Viittaus:}
            \NormalTok{viittaukset.append(arvo)}
    \NormalTok{emit(sivu_id, (page_rank, viittaukset))}
\end{Highlighting}
\end{Shaded}

\section{Muut hajautetun laskennan
ratkaisut}\label{muut-hajautetun-laskennan-ratkaisut}

MapReduce-ohjelmointimalli ei ole ainoa tai ensimmäinen ratkaisu suurien
tietomäärien käsittelyyn. Tässä luvussa tutustutaan kahteen muuhun
hajautetun laskennan ratkaisuun ja verrataan näitä ratkaisuja
MapReduce-ohjelmointimalliin.

\subsection{Hajautetut
relaatiotietokantajärjestelmät}\label{hajautetut-relaatiotietokantajuxe4rjestelmuxe4t}

Relaatiotietokantajärjestelmien ja SQL-kyselykielen suosion vuoksi
saattaa olla houkuttelevaa käyttää kyselykieltä myös suurien
tietomäärien analysoinnissa -- SQL saattaa olla ohjelmoijalle valmiiksi
tuttu, tai kenties kehityksen kohteena oleva järjestelmä käyttää jo
SQL-kyselykieltä hyödyntävää tietokantaa hyväkseen.

Tiedon käsittely MapReduce-ohjelmointimallilla ja
relaatiotietokantajärjestelmillä eroaa monin tavoin, muun muassa
seuraavasti:

\begin{itemize}
\item
  \textbf{Ohjelmointimalli}: MapReduce-ohjelmointimallin käyttäjä
  toteuttaa tiedon käsittelyn \emph{map}- ja \emph{reduce}-funktioiden
  avulla. \emph{Map}- ja \emph{reduce}-funktiot toteutetaan tavallisesti
  yleiskäyttöisellä ohjelmointikielellä. Tästä seuraa, että funktioiden
  sisältämälle logiikalle tai sisäiselle rakenteelle ei ole asetettu
  rajoituksia. Relaatiotietokannassa tiedon käsittely tehdään
  SQL-kyselykielellä, jolla -- toisin kuin \emph{map}- tai
  \emph{reduce}-funktioilla -- kuvataan kyselyn haluttua tulosta eikä
  laskennan yksityiskohtia \cite{mapreduce-comparison}. Suurin osa
  tunnetuista relaatiotietokantajärjestelmistä tukee kuitenkin myös
  jonkinlaista ohjelmointikieltä kyselyiden rakentamisessa.
\item
  \textbf{Tiedon rakenne}: MapReduce-ohjelmointimalli ei ota kantaa
  syötteen tai tuloksen rakenteeseen \cite{mapreduce2}.
  Relaatiotietokannat käyttävät tiedon ilmaisemiseen kaksiulotteisia
  tauluja, joiden rakenne määritellään ennen kuin tietokantaan voidaan
  lisätä sisältöä \cite{mapreduce-comparison}.
\item
  \textbf{Suoritus}: MapReduce-ohjelmointimalli sellaisenaan rajoittuu
  malliin, jossa tieto käy ensin \emph{map}- ja sen jälkeen
  \emph{reduce}-vaiheen läpi. Koska SQL-kyselyissä ei esitetä laskennan
  yksityiskohtia, voi käytetty relaatiotietokantajärjestelmä valita
  kyselylle parhaan mahdollisen suoritusmallin
  \cite{mapreduce-comparison}.
\end{itemize}

Stonebraker ja muut vertasivat työssään \cite{mapreduce-comparison2}
Hadoop-kirjaston suorituskykyä hajautettuihin
relaatiotietokantajärjestelmiin 100 tietokoneen klusterilla.
Suorituskykytesteissä hajautetun relaatiotietokantajärjestelmän
\emph{Vertican} sekä toisen, nimeämättä jätetyn hajautetun
relaatiotietokantajärjestelmän havaittiin olevan merkittävästi
testattuja kyselyitä vastaavia Hadoop-ohjelmia tehokkaampia. Osasyyksi
todetaan Hadoop-ohjelmien indeksoinnin puute -- toisaalta, kuten luvussa
3.2 todetaan, indeksien käyttö MapReduce-sovelluksissa ei ole
mahdotonta. Testatut hajautetut relaatiotietokantajärjestelmät olivat
kuitenkin nopeampia myös tehtävissä, joissa indeksointia ei voitu
hyödyntää. Artikkelissa kuitenkin todetaan, että tulokset kertovat
enemmän testattujen järjestelmien kuin niiden käyttämien mallien
eroista.

On olemassa myös järjestelmiä, jotka mahdollistavat perinteisten
relaatiotietokantajärjestelmien käytön hajautetusti -- tällaisia
järjestelmiä ovat esimerkiksi \emph{pgpool-II} \cite{pgpool-site}
sekä MapReduce-ohjelmointimallia toteutuksessaan hyödyntävä
\emph{HadoopDB} \cite{hadoopdb}. Molemmat toimivat ylimääräisenä
kerroksena käyttäjän ja itsenäisten PostgreSQL-tietokantapalvelinten
välissä. MapReduce-ohjelmointimallin joustavuuden vuoksi sen päälle voi
rakentaa lisäksi järjestelmiä, joiden avulla MapReduce-laskentatehtäviä
voidaan määrittää SQL:ää muistuttavan kyselykielen avulla. Esimerkki
tällaisesta järjestelmästä on \emph{Apache Hive} \cite{hive}.

\subsection{Spark}\label{spark}

Spark on Scala-ohjelmointikielellä toteutettu ohjelmointikehys
hajautettua laskentaa varten \cite{spark}. Ohjelmistokehyksen
esitetään MapReduce-ohjelmointimalliin verrattuna helpottavan
käyttötarkoituksia, joissa samaa joukkoa tietoa käytetään useaan
kertaan. Tällaisia ovat muun muassa iteratiiviset algoritmit, kuten
luvussa 4 esitelty algoritmi PageRank-menetelmän toteuttamiseen.

Spark-ohjelmointikehyksen käyttämä abstraktio on \emph{kestävät,
hajautetut tietojoukot} (Resilient Distributed Dataset, RDD), jotka ovat
kokoelma laskennassa käytettäviä alkioita \cite{rdd}. Kestäviä,
hajautettuja tietojoukkoja voidaan niiden luomisen jälkeen ainoastaan
lukea, joten kaikki muutokset tietojoukkoihin luovat uuden tietojoukon.
Käyttäjän näkökulmasta hajautettu laskenta Spark-ohjelmistokehyksellä
muistuttaa MapReduce-ohjelmointimallin käyttämistä: käyttäjä voi
käsitellä kestäviä, hajautettuja tietojoukkoja erilaisin funktioin.
Funktioihin kuuluvat muun muassa \emph{flatMap}- ja \emph{reduceByKey},
joilla tietoa voidaan käsitellä MapReduce-ohjelmointimallin \emph{map}-
ja \emph{reduce}-funktioiden tapaan.

Seuraava esimerkki havainnollistaa, miten saman tietojoukon käyttäminen
useaan kertaan onnistuu Spark-ohjelmistokehystä käytettäessä:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// olkoon muuttuja "rdd" jokin kokonaislukuja sisältävä}
\CommentTok{// tietojoukko}
\KeywordTok{var} \NormalTok{parilliset = rdd.}\FunctionTok{filter}\NormalTok{(x -> x % }\DecValTok{2} \NormalTok{== }\DecValTok{0}\NormalTok{).}\FunctionTok{cache}\NormalTok{()}
\KeywordTok{var} \NormalTok{maara = parilliset.}\FunctionTok{count}\NormalTok{()}
\KeywordTok{var} \NormalTok{summa = parilliset.}\FunctionTok{reduce}\NormalTok{((a, b) -> (a + b))}
\end{Highlighting}
\end{Shaded}

Esimerkissä suodatetaan tietojoukko \emph{filter}-funktion avulla niin,
että suodatuksen tuloksena saadussa uudessa tietojoukossa on vain
alkuperäisen tietojoukon parilliset alkiot. \emph{Cache}-funktion käyttö
kertoo Spark-ohjelmistokehykselle, että tietojoukko kannattaa pyrkiä
säilyttämään muistissa sen ensimmäisen laskentakerran jälkeen.

Tällainen laskettujen tulosten uudelleenkäyttö on kuitenkin mahdollista
myös MapReduce-ohjelmointimallin avulla -- yhden
MapReduce-laskentatehtävän tulos voidaan tallentaa ja käyttää sitä
muissa MapReduce-laskentatehtävissä. Spark-ohjelmistokehyksen esitetään
kuitenkin toimivan MapReduce-ohjelmointimallia tehokkaammin, sillä
MapReduce-laskentatehtävien täytyy tallentaa ja ladata tulokset levyltä
\cite{spark}. Kuitenkin, koska MapReduce-ohjelmointimallissa
tulosten tallennuskohteena toimivaa tekniikkaa ei ole rajoitettu,
voidaan tulokset tallentaa ja ladata esimerkiksi muistissa toimivasta
hajautetusta tiedostojärjestelmästä.

Kestävien, hajautettujen tietojoukkojen lisäksi
Spark-ohjelmistokehyksessä on ominaisuuksia, joilla voidaan hallita
laskentaan osallistuvien tietokoneiden välistä yhteistä tilaa
\cite{spark}. Esimerkiksi \emph{yleislähetys}-muuttujien (broadcast)
avulla voidaan lähettää tietoa kaikille tietokoneille tehokkaasti. Tätä
ominaisuutta voisi käyttää esimerkiksi luvussa 4 esitellyn
PageRank-algoritmin sivujen välisten yhteyksien lähettämiseen kaikille
tietokoneille.

Lei Gu ja Huan Li vertasivat Hadoop- ja Spark-ohjelmistokehyksien
suorituskykyä iteratiivisissa laskentatehtävissä
\cite{spark-hadoop-comparison}. Spark-ohjelmien todettiin olevan
keskimäärin Hadoop-ohjelmia nopeampia, mutta käyttävät enemmän
keskusmuistia sekä hidastuvat, jos keskusmuistia ei ole käytössä
riittävästi.

\section{Yhteenveto}\label{yhteenveto}

MapReduce on ohjelmointimalli, jota voi käyttää suurten tietojoukkojen
käsittelyyn ja luomiseen. MapReduce-ohjelmointimalli helpottaa
hajautettua laskentaa käyttävien ohjelmien luomista monin tavoin:
käyttämällä ohjelmointimallin toteuttavaa kirjastoa käyttäjän ei
tarvitse huolehtia useista hajautettuun laskentaan liittyvistä
yksityiskohdista, ja luvussa 2 käsiteltyjen esimerkkien perusteella
ohjelmointimallin käyttö yksinkertaisten ohjelmien luomiseen on
suoraviivaista.

MapReduce-ohjelmointimallin yksinkertaisuudesta seuraa kuitenkin, että
sellaisenaan se soveltuu tiettyihin käyttötarkoituksiin huonosti.
MapReduce-ohjelman on esimerkiksi käytävä koko sen saama syöte läpi,
joka joissain sovelluksissa vähentää suorituskykyä tarpeettomasti.
Ohjelmointimallin joustavuudesta kuitenkin kertoo, että sen puutteita
voidaan paikata muuttamalla ohjelmointimallin toimintaa sopivasti:
laajentamalla ohjelmointimallia \emph{indeksoinnilla} vältetään koko
syötteen käyminen läpi, ja laskentaan osallistuvien tietokoneiden
välistä kommunikaatiota voidaan vähentää käyttämällä
\emph{combiner}-funktiota. Muutokset eivät kuitenkaan ole puhtaasti
suorituskykyä parantavia -- esimerkiksi indeksin rakentaminen vähentää
turhaan suorituskykyä, jos indeksille ei ole käyttöä. Niinpä käyttäjän
on punnittava eri laajennosten hyötyjä ja haittoja sovelluskohtaisesti.

MapReduce-ohjelmointimallia voidaan käyttää monentyyppisten algoritmien
toteuttamiseen. Luvussa 3 esitelty PageRank-menetelmän toteuttava
ohjelma osoittaa, että ohjelmointimalli soveltuu yksinkertaisten
ohjelmien lisäksi esimerkiksi verkkoja käyttävien tai iteratiivisten
algoritmien toteuttamiseen.

Spark on hajautettuun laskentaan tarkoitettu ohjelmistokehys, jolla
voidaan käsitellä tietoa MapReduce-ohjelmointimallin tapaan.
Spark-ohjelmistokehys sisältääkin funktiot, jotka vastaavat
MapReduce-ohjelmointimallista löytyviä \emph{map}- ja
\emph{reduce}-funktioita, tarjoten kuitenkin myös lisää ominaisuuksia
MapReduce-ohjelmointimalliin verrattuna. Ohjelmistokehys helpottaa
tietoa useaan kertaan käyttävien algoritmien toteuttamista sekä
laskentaan osallistuvien tietokoneiden välisen yhteisen tilan hallintaa.

Hajautetut relaatiotietokantajärjestelmät sen sijaan eroavat
MapReduce-ohjelmointimallista selkeämmin, ja molemmissa on toisiinsa
verrattuna hyviä sekä huonoja puolia. Yleiskäyttöisen ohjelmointikielen
sijaan relaatiotietokannoissa käytetään yleensä SQL-kyselykieltä, joka
kuvaa laskennan yksityiskohtien sijaan haluttua tulosta.
Relaatiotietokannoissa käytetään tiedon esittämiseen kaksiulotteisia
taulukoita, kun taas MapReduce-ohjelmointimallissa tiedon esittämiseen
käytettyä mallia ei ole rajoitettu. Toisaalta, koska kyselyissä ei
määritellä laskennan yksityiskohtia, relaatiotietokantajärjestelmät ovat
vapaita suorittamaan kyselyt parhaaksi katsomallaan tavalla.

Tutkielman tarkoituksena oli luoda katsaus MapReduce-ohjelmointimalliin,
sen toimintaan sekä näyttää, miten ohjelmointimallia voi hyödyntää
tiedon käsittelyssä. Tutkielma ei ole kovinkaan kattava katsaus
erilaisiin MapReduce-ohjelmointimalliin liittyviin asioihin.
Ulkopuolelle ovat jääneet esimerkiksi usein MapReduce-ohjelmointimallin
kanssa käytetyt hajautetut tiedostojärjestelmät ja niihin liittyvät
MapReduce-ohjelmointimallin optimoinnit. On olemassa myös hajautetun
laskennan järjestelmiä, joita ei tässä tutkielmassa verrattu
MapReduce-ohjelmointimalliin. Esimerkki tälläisestä järjestelmästä on
Spark-ohjelmistokehyksen päälle rakennettu GraphX-kirjasto, jota voidaan
käyttää verkkojen käsittelyyn.

% --- References ---
%
% bibtex is used to generate the bibliography. The babplain style
% will generate numeric references (e.g. [1]) appropriate for theoretical
% computer science. If you need alphanumeric references (e.g [Tur90]), use
%
% \bibliographystyle{babalpha-lf}
%
% instead.

\bibliographystyle{babplain-lf}
\bibliography{src/lahteet}

% --- Appendices ---

% uncomment the following

% \newpage
% \appendix
% 
% \section{Esimerkkiliite}

\end{document}
